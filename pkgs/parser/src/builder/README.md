# AST Construction

## Visitors

The construction of an abstract syntax tree is pretty straightforward. We use
the `DyadNodeVisitor` interface provided by the `gendts.mts` script (_i.e.,_
generated automatically from our `chevrotain` grammar) to walk the concrete
syntax tree and build the abstract syntax tree.

## Visitor Methods and Types

Note that the visitors generated by `chevrotain` feature parameterized types. In
our case we are implementing `DyadNodeVisitor<any,any>` where the first type
parameter is the type of the arguments passed _into_ rules as we walk the tree
and teh second type parameter is the type _returned_ by the rules. We benefit
significantly here from the fact that even thought our visitor is implementing
`DyadNodeVisitor<any, any` (which is completely generic), TypeScript allows
us to use _more specific_ types for each rule method. So, for example, our
`file` method looks like this:

```typescript
file(children: FileCstChildren, filename: string): FileContents {
    ...
}
```

Furthermore, all other rules _in this class_ will use the narrower types. This
means that, for example, if we invoke the `connector` rule which is defined like
this:

```typescript
connector(children: ConnectorCstChildren, param?: void): ConnectorDefinition {
    ...
}
```

...the type of the value returned from this rule (when invoked by another method
in this class) will be inferred to be `ConnectorDefinition`. This is very
useful.

## Patterns

Each node in our concrete syntax tree contains only two pieces of information.
The first is the node type represented by the `name` field. The other field are
the "children" of this node represented by the `children` field. For each node
type, there is also a corresponding type for the children associated with the
node (this is the type of the `children` field, in fact).

But things are not quite as simple as we might hope because all children are
represented by arrays (or not present) even if there is only one instance of the
expected information. To understand this, let's examine the following rule in
our grammar:

```typescript
public base_class = this.RULE("base_class", () => {
  this.CONSUME3(Identifier, { LABEL: "base" });
  this.OPTION(() => {
    this.CONSUME(LParen);
    this.MANY_SEP({
      SEP: Comma,
      DEF: () => {
        this.CONSUME(Identifier, { LABEL: "attribute" });
        this.CONSUME1(Equals);
        // This should really be a component reference
        this.SUBRULE(this.expression);
      },
    });
    this.CONSUME(RParen);
  });
});
```

Note that this rule consumes _exactly one_ token labeled `base` and zero or more
tokens labeled `attribute`. Furthermore, it also includes zero or more instances
of CST nodes associated with the `expression` rule.

This results in the following node definition:

```typescript
export interface Base_classCstNode extends CstNode {
  name: "base_class";
  children: Base_classCstChildren;
}
```

...which also has this corresponding children type definition:

```typescript
export type Base_classCstChildren = {
  base: IToken[];
  LParen?: IToken[];
  attribute?: IToken[];
  Equals?: IToken[];
  expression?: ExpressionCstNode[];
  Comma?: IToken[];
  RParen?: IToken[];
};
```

Note that despite the fact that the grammar only consumes exactly one token for
`base`, it is represented among the children as an `IToken[]`. Note that all
"zero or more" cases are also represented by arrays but these are _optional_.

For this reason, we have to do various "conversions" to a) ensure that the type
is what we expect and b) cast it into the proper "arity" for our purposes. We
can leverage the `mapSingleton`, `mapArray` and `mapOptional` functions. These
handle the cases of "exactly one", "zero or more" and "one or zero" cases,
respectively. So for the processing of the children of a `base_class` node, we
process the children as follows:

```typescript
base_class(children: Base_classCstChildren, param?: void): TypeQualifier {
  const base = mapSingleton(children, "base", asImage);
  const keys = mapArray(children, "attribute", asImage);
  const exprs = mapArray(children, "expression", this.asExpression);
  const mods = Object.fromEntries(zip(keys, exprs));
  return {
    name: base,
    mods: mods,
  };
```

Note the use of `mapSingleton` and `mapArray`. True to their names, this are
actually map operations. This means that they are not so much interested in the
tokens or CST nodes but rather in _processing_ those into something else. So the
third argument is the "processing" function which transforms either the token or
the node into something. Often times, the processing is simply invoking the
visitor method for another rule as is the case with `this.asExpression` which is
a helper method that extracts the children from the node and then invokes
`this.expression` (along with rebinding of `this` which is necessary because
this is Javascript). Similarly, the `asImage` function simply extracts the
actual text of the token.
