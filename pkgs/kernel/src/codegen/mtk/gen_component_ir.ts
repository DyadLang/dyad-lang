import {
  failedResult,
  partialResult,
  Problem,
  Result,
} from "@juliacomputing/dyad-common";
import { ComponentIR } from "./component_ir.js";
import { ModelInstance } from "../../instantiate/model.js";
import { partialProblem } from "./errors.js";
import { ComponentDefinition } from "@juliacomputing/dyad-ast";

export function generateComponentIR(
  def: ComponentDefinition,
  instance: ModelInstance
): Result<ComponentIR> {
  const problems: Problem[] = [];
  const ret: ComponentIR = {
    comment: null,
    doc_string: instance.doc_string?.value ?? null,
    function_name: instance.name.value,
    positional_arguments: [],
    keyword_arguments: {},
    structural_assertions: [],
    parameter_assertions: [],
    temporary_variables: [],
    structural_parameters: [],
    symbolic_parameters: [],
    symbolic_variables: [],
    symbolic_constants: [],
    system: [],
    defaults: [],
    initialization_equations: [],
    equations: [],
    connections: [],
  };

  /**
   * If this component is partial, then there is nothing to do here.  Ideally,
   * the caller of this function would simply avoid calling it in this case vs.
   * handling the failure.
   */
  if (instance.qualifier === "partial") {
    return failedResult(partialProblem(def, instance));
  }

  /**
   * If this component is external, make that clear in the comments.
   */
  if (instance.qualifier === "external") {
    ret.comment += [
      `# Component ${instance.name.value} is an external component definition.  This means that the`,
      `# code for this component should be written in native Julia and will not be generated by`,
      `# the dyad compiler`,
    ].join("\n");
  }
  return partialResult(ret, ...problems);
}
