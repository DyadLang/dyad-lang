import {
  Problem,
  Result,
  toProblems,
  baseLibraryName,
  assertUnreachable,
  Lines,
  objectMap,
} from "@juliacomputing/dyad-common";
import {
  ContinuitySetInstance,
  ConnectorInstance,
  EquationInstance,
  ModelInstance,
  ScalarConnectorInstance,
  stringifyContinuitySets,
  VariableInstance,
  AnalysisPointInstance,
  ConnectionInstance,
  isEquationInstance,
  isAnalysisPointInstance,
  isConnectionInstance,
  RelationInstance,
  isControlFlowInstance,
} from "../../instantiate/index.js";
import { unparseMTKEquation, unparseMTKExpression } from "../equation.js";
import {
  CompRef,
  ComponentDefinition,
  Definition,
  Expression,
  FileLevelNode,
  QualifiedType,
  compRef,
  createToken,
  deref,
  functionCall,
  hasExpression,
  qualifiedName,
  stringLiteral,
  transformExpression,
} from "@juliacomputing/dyad-ast";
import { normalizeDefinition } from "../../metadata/index.js";
import { castOrThrow, generateDiagram, getStringEither } from "../../index.js";
import {
  QueryHandler,
  ResolvedType,
  extractGuess,
  getDefinitionRelations,
  problemSpan,
  resolveType,
  stringifyProblem,
} from "../../workspace/index.js";

import debug from "debug";
import {
  MTKHandler,
  ModuleName,
  definitionKey,
  experimentKey,
  testKey,
} from "./events.js";
import {
  connectorDocString,
  generateDocStringAsComment,
  parameterDocString,
  variableDocString,
} from "./docs.js";
import { FullyQualifiedName } from "./fqn.js";
import {
  CompilerAssertionError,
  UnimplementedError,
} from "../../workspace/errors.js";
import { finalNoInit } from "../../instantiate/errors.js";
import { MTKCodeGenerationOptions } from "./options.js";
import { Just, Maybe, Nothing } from "purify-ts/Maybe";
import { unparseExpression } from "@juliacomputing/dyad-parser";
import { ComponentInstance } from "../../instantiate/component.js";
import { getLibraryNode } from "../../workspace/selectors/nodes.js";
import { partialProblem } from "./errors.js";
import { isAssertionInstance } from "../../instantiate/assertion.js";
import { buildEnumStructName } from "./enum.js";

export type Entries<T> = Array<[string, T]>;

const modelLog = debug("codegen:mtk:model");
const instanceLog = debug("codegen:inst");

const systemsVariable = `__systems`;
const parametersVariable = `__params`;
const variablesVariable = `__vars`;
const equationsVariable = `__eqs`;
const initialEquationsVariable = "__initialization_eqs";
const defaultsVariable = "__defaults";
const constantsVariable = "__constants";

export async function generateComponentDiagram(
  instance: ModelInstance,
  query: QueryHandler
) {
  return await generateDiagram("", instance, query);
}

export async function emitComponent(
  instance: ModelInstance,
  query: QueryHandler,
  module: ModuleName,
  diagram: string,
  handler: MTKHandler,
  options: MTKCodeGenerationOptions
): Promise<Array<Problem<any>>> {
  modelLog(
    "Emitting component %s in module .%s",
    instance.name.value,
    module.join(".")
  );
  const def = query(instance.def);
  const ret: Problem[] = [];
  const deflines: string[] = [];
  const testlines: string[] = [];
  const explines: string[] = [];
  const precomplines: string[] = [];

  try {
    // QUESTION: Should we publish partial models (allowing MTK models to extend
    // from Dyad models) or should we require extension only via Dyad?
    if (instance.qualifier === "partial") {
      ret.push(partialProblem(def, instance));
    }

    if (instance.qualifier === "external") {
      deflines.push(
        `# Component ${instance.name.value} is an external component definition.  This means that the`,
        `# code for this component should be written in native Julia and will not be generated by`,
        `# the Dyad compiler.  Dyad will only generate a stub that creates the function name.`,
        `# The implementation of the function (function ${instance.name.value}(; name, params...))`,
        `# must be manually written.`,
        `function ${instance.name.value} end`,
        `export ${instance.name.value}`
      );
    }

    const et = enumConstructorTransform(query, instance);
    const enumTransform = (v: VariableInstance) => {
      v.default.ifJust((e) => {
        v.default = Just(et(e));
      });
      return v;
    };
    const connectors = Object.entries(instance.connectors);
    const components = Object.entries(instance.components);
    const variables = Object.entries(instance.variables);
    const structural = Object.entries(
      objectMap(instance.structural, enumTransform)
    );
    const parameters = Object.entries(instance.parameters);
    const constants = Object.entries(instance.constants);
    const paths = Object.entries(instance.pathVariables);
    const connectorPathVariables = extractConnectorPathVariables(connectors);
    const pathTransform = pathVariableTransform(connectorPathVariables);

    modelLog(
      "Connector path variables for %s are %j",
      def.name.value,
      connectorPathVariables
    );

    instanceLog("Instance of %s: %j", instance.name, instance);

    if (instance.qualifier !== "external") {
      const kwargs: string[] = [
        "name",
        ...structural.filter((x) => !x[1].final).map((x) => x[0]),
        ...parameters.filter((x) => !x[1].final).map((x) => x[0]),
      ];
      const doc_string: string[] = [
        `   ${instance.name.value}(; ${kwargs.join(", ")})`,
        instance.doc_string === null ? "" : instance.doc_string.value,
        parameterDocString(
          structural,
          parameters.filter((x) => !x[1].final)
        ),
        connectorDocString(connectors),
        variableDocString(variables),
      ].filter((x) => x !== "");

      if (doc_string.length > 0) {
        deflines.push(`@doc Markdown.doc"""
${doc_string.join("\n\n")}
"""`);
      }

      // Construct function arguments.  Name is always present, plus the names
      // of all variables
      const args = [
        "name",
        ...formulateStructuralParameterArguments(structural),
        ...formulateParametricParameterArguments(parameters),
        ...formulatePathParameterArguments(instance.pathVariables),
        ...formulateCommonArguments(instance.continuityGraph),
      ];

      modelLog("Writing header for component %s", instance.name.value);

      deflines.push(
        `@component function ${instance.name.value}(; ${args.join(", ")})`
      );

      // Add assertions
      const assertions = instance.relations
        .filter(isAssertionInstance)
        .map((assertion) => ({
          expr: pathTransform(assertion.expr),
          message: assertion.message,
        }));
      for (const assertion of assertions) {
        deflines.push(
          `  @assert ${unparseMTKExpression(assertion.expr)} "${
            assertion.message
          }"`
        );
      }

      for (const [cn, c] of structural) {
        if (c.type.resolves === "fun" && c.default.isJust()) {
          deflines.push(
            `  ${cn}ˍ₋value = ${unparseMTKExpression(c.default.unsafeCoerce())}`
          );
        }
      }

      // Turns out we don't need this so long as the structural parameters
      // are declared as arguments to the function itself.
      // if (structural.length > 0) {
      //   deflines.push(`  ### Structural Parameters`);
      //   deflines.push(`  @structural_parameters begin`);
      //   for (const [cn, c] of structural) {
      //     parameterDeclaration(cn, c, def, options, null, pathTransform).ifJust(
      //       (line) => deflines.push(line)
      //     );
      //   }
      //   deflines.push(`  end`);
      // }

      for (const [cn, c] of paths) {
        if (c.type.resolves === "fun" && c.default.isJust()) {
          deflines.push(
            `  ${cn}ˍ₋value = ${unparseMTKExpression(c.default.unsafeCoerce())}`
          );
        }
      }
      for (const [cn, c] of parameters) {
        if (c.type.resolves === "fun" && c.default.isJust()) {
          deflines.push(
            `  ${cn}ˍ₋value = ${unparseMTKExpression(c.default.unsafeCoerce())}`
          );
        }
      }

      deflines.push(``, `  ### Symbolic Parameters`);
      deflines.push(`  ${parametersVariable} = Any[]`);
      /** First, do all non-final path variables */
      for (const [cn, c] of paths) {
        c.default.caseOf({
          Just: () => {
            if (!c.final) {
              deflines.push(
                `  append!(${parametersVariable}, @parameters (${cn}::${determineMTKType(c.type)} = ${cn}))`
              );
            }
          },
          Nothing: () => {
            ret.push(
              new CompilerAssertionError(
                "emitComponent",
                `Expected path variable to have a default value, bit it was missing`
              )
            );
          },
        });
      }

      for (const [cn, c] of parameters) {
        parameterDeclaration(
          cn,
          c,
          def,
          options,
          parametersVariable,
          pathTransform
        ).ifJust((line) => deflines.push(line));
      }
      /** Now do all final path variables (because these might depend on parameters) */
      for (const [cn, c] of paths) {
        c.default.caseOf({
          Just: () => {
            if (c.final) {
              const rhs = c.default.mapOrDefault(
                unparseMTKExpression,
                "nothing"
              );
              deflines.push(
                `    (${cn}::${determineMTKType(c.type)} = ${rhs})`
              );
            }
          },
          Nothing: () => {
            ret.push(
              new CompilerAssertionError(
                "emitComponent",
                `Expected path variable to have a default value, bit it was missing`
              )
            );
          },
        });
      }
      /**
       * Now we need to map the set master for each common set to any
       * local variables
       */
      for (let setn = 0; setn < instance.continuityGraph.length; setn++) {
        const set = instance.continuityGraph[setn];
        const master = set.master.mapOrDefault(
          (x) => unparseExpression(x),
          masterArgumentName(setn)
        );
        for (let local of set.local) {
          deflines.push(
            `  append!(${parametersVariable}, @parameters (${local.elems[0].name}__${
              local.elems[1].name
            }::${determineMTKType(set.type)} = ${master}))`
          );
        }
      }

      modelLog("Analyzing paths in %s", instance.name.value);

      modelLog("Generating subcomponents for %s", instance.name.value);

      const dcons = connectors.filter(
        (x): x is [string, ScalarConnectorInstance] => x[1].kind === "sclcon"
      );

      const varlines: string[] = [];
      if (dcons.length > 0) {
        for (const [cn, c] of dcons) {
          const metadata: string[] = [];
          metadata.push(`${c.def.qualifier} = true`);
          varlines.push(
            `  append!(${variablesVariable}, @variables ${cn}(t), [${metadata.join(", ")}])`
          );
        }
      }

      if (variables.length > 0) {
        for (const [cn, c] of variables) {
          variableDeclaration(cn, c, options).ifJust((line) => {
            varlines.push(line);
          });
        }
      }

      deflines.push(``, `  ### Variables`);
      deflines.push(`  ${variablesVariable} = Any[]`);
      deflines.push(...varlines);

      /**
     * begin
        @symcheck J > 0 || throw(ArgumentError("Expected `J` to be positive"))
       end
     */

      deflines.push(``, `  ### Constants`);
      for (const [cn, c] of constants) {
        if (c.type.resolves === "fun" && c.default.isJust()) {
          deflines.push(`  # Initializer expressions for ${cn}`);
          deflines.push(
            `  ${cn}ˍ₋value = ${unparseMTKExpression(c.default.unsafeCoerce())}`
          );
        }
      }
      deflines.push(`  ${constantsVariable} = Any[]`);
      for (const [cn, c] of constants) {
        parameterDeclaration(
          cn,
          c,
          def,
          options,
          constantsVariable,
          pathTransform
        ).ifJust((line) => deflines.push(line));
      }

      deflines.push(``, `  ### Components`);
      deflines.push(`  ${systemsVariable} = ODESystem[]`);
      const syslines = generateSubcomponents(
        query,
        instance,
        connectors,
        components
      );
      deflines.push(...syslines);

      const transformer = transformEquations(pathTransform);

      const all_equations = instance.relations
        .filter(isEquationInstance)
        .map(transformer);

      const initial_equations = all_equations.filter((x) => x.initial);
      const equations = all_equations.filter((x) => !x.initial);

      const simple_initial_equations =
        initial_equations.filter(isSimpleEquation);
      const advanced_initial_equations = initial_equations.filter(
        (x) => !isSimpleEquation(x)
      );

      deflines.push(``, `  ### Defaults`);
      deflines.push(`  ${defaultsVariable} = Dict()`);
      for (const eq of simple_initial_equations) {
        deflines.push(emitRelation(eq, instance, query, "  "));
      }

      deflines.push(``, `  ### Initialization Equations`);
      deflines.push(`  ${initialEquationsVariable} = []`);
      for (const eq of advanced_initial_equations) {
        deflines.push(...generateDocStringAsComment(eq.doc_string, "  "));
        deflines.push(emitRelation(eq, instance, query, "  "));
      }

      const analysis_points = instance.relations
        .filter(isAnalysisPointInstance)
        .map((rel): [string, AnalysisPointInstance] => [rel.name.value, rel]);

      deflines.push(``, `  ### Equations`);
      deflines.push(`  ${equationsVariable} = Equation[]`);
      for (const eq of equations) {
        deflines.push(...generateDocStringAsComment(eq.doc_string, "  "));
        deflines.push(emitRelation(eq, instance, query, "  "));
      }
      for (const [_name, ap] of analysis_points) {
        deflines.push(...generateDocStringAsComment(ap.doc_string, "  "));
        deflines.push(emitRelation(ap, instance, query, "  "));
      }
      for (const con of instance.relations.filter(isConnectionInstance)) {
        deflines.push(...generateDocStringAsComment(con.doc_string, "  "));
        deflines.push(emitRelation(con, instance, query, "  "));
      }

      const controls = instance.relations.filter(isControlFlowInstance);
      if (controls.length > 0) {
        deflines.push(``, `  ### Control Structures`);
        for (const rel of controls) {
          deflines.push(emitRelation(rel, instance, query, "  "));
        }
      }

      deflines.push(``, `  # Return completely constructed ODESystem`);
      deflines.push(
        `  return ODESystem(${equationsVariable}, t, ${variablesVariable}, ${parametersVariable}; systems=${systemsVariable}, defaults=${defaultsVariable}, name, initialization_eqs=${initialEquationsVariable})`
      );
      deflines.push("end");

      deflines.push(`export ${instance.name.value}`);

      if (instance.definition_metadata) {
        modelLog(
          "Got instance metadata for %s of: %j",
          instance.name,
          instance.definition_metadata
        );
        const normalized = normalizeDefinition(instance.definition_metadata);
        modelLog(
          "Normalized Dyad metadata for %s: %j",
          instance.name,
          normalized
        );

        // Write out experiments
        for (const [name, exp] of Object.entries(normalized.Dyad.experiments)) {
          modelLog("Emiting experiment %s", name);
          const params = Object.entries(exp.params)
            .map(([k, v]) => `${k}=${v}`)
            .join(",");
          const ics = Object.entries(exp.initial)
            .map(([k, v]) => `model.${k} => ${v}`)
            .join(", ");
          explines.push(
            ...[
              `"""Run model ${instance.name.value} from ${exp.start} to ${exp.stop}"""`,
              `function ${name}()`,
              `  @mtkbuild model = ${instance.name.value}(${params})`,
              `  u0 = [${ics}]`,
              `  prob = ODEProblem(model, u0, (${exp.start}, ${exp.stop}))`,
              `  sol = solve(prob)`,
              `end`,
              `export ${name}`,
            ]
          );

          modelLog("  Experiment: %j", explines);

          // Every experiment is also a basic test insomuch as it should
          // run without throwing an exception.
          testlines.push(
            ...[
              `@test try`,
              `    ${name}()`,
              `    true`,
              `catch`,
              `    false`,
              `end`,
            ]
          );

          // Experiments are also good for precompilation code
          precomplines.push(`${name}()`);
        }

        // Write out tests
        for (const [caseName, caseDef] of Object.entries(
          normalized.Dyad.tests
        )) {
          const params = Object.entries(caseDef.params)
            .map(([k, v]) => `${k}=${v}`)
            .join(",");
          const ics = Object.entries(caseDef.initial)
            .map(([k, v]) => `model.${k} => ${v}`)
            .join(", ");

          testlines.push(
            ...[
              `@testset "Running test ${caseName} for ${instance.name.value}" begin`,
              `  using CSV, DataFrames, Plots`,
              ``,
              `  @mtkbuild model = ${instance.name.value}(${params})`,
              `  u0 = [${ics}]`,
              `  prob = ODEProblem(model, u0, (${caseDef.start}, ${caseDef.stop}))`,
              `  sol = solve(prob, ${caseDef.solver}())`,
              `  @test SciMLBase.successful_retcode(sol)`,
            ]
          );
          for (const [signal, initial] of Object.entries(
            caseDef.expect.initial
          )) {
            const atol = caseDef.atol[signal];
            const suffix = atol ? ` atol=${atol}` : "";
            const deref = signal === "t" ? "sol.t" : `sol[model.${signal}]`;
            testlines.push(`  @test ${deref}[1] ≈ ${initial}${suffix}`);
          }
          for (const [signal, final] of Object.entries(caseDef.expect.final)) {
            const atol = caseDef.atol[signal];
            const suffix = atol ? ` atol=${atol}` : "";
            const deref = signal === "t" ? "sol.t" : `sol[model.${signal}]`;
            testlines.push(`  @test ${deref}[end] ≈ ${final}${suffix}`);
          }

          const signalList = caseDef.expect.signals;
          testlines.push(
            `# Signals selected for regression testing: ${JSON.stringify(
              signalList
            )}`
          );
          testlines.push(
            `  ref_times = [sol(t, idxs=:t) for t in LinRange(sol[:t][1], sol[:t][end], 100)]`
          );
          testlines.push(`  if get(ENV, "DYAD_UPDATE_REFS", "") !== ""`);
          testlines.push(
            `    # If asked to update snapshots, write out reference data for all signals`
          );
          testlines.push(`    mkpath("snapshots")`);
          for (
            let signalIndex = 0;
            signalIndex < signalList.length;
            signalIndex++
          ) {
            const signal = signalList[signalIndex];
            testlines.push(
              `    CSV.write("snapshots/${instance.name.value}_${caseName}_sig${signalIndex}.ref", DataFrame(t=ref_times, expected=[sol(t, idxs=model.${signal}) for t in ref_times]))`
            );
          }
          testlines.push(`  end`);
          for (
            let signalIndex = 0;
            signalIndex < signalList.length;
            signalIndex++
          ) {
            const id = `${instance.name.value}_${caseName}_sig${signalIndex}`;
            const signal = signalList[signalIndex];
            testlines.push(`    if isfile("snapshots/${id}.ref")`);
            testlines.push(
              `      ref = CSV.read("snapshots/${id}.ref", DataFrame)`
            );
            const atol = caseDef.atol[signal];
            const suffix = atol ? ` atol=${atol}` : "";
            testlines.push(
              `      [@test ref.expected[i] ≈ sol(ref.t[i], idxs=model.${signal})${suffix} for i in 1:length(ref.expected)]`
            );
            testlines.push(`      if get(ENV, "DYAD_COMPARISONS", "") !== ""`);

            testlines.push(
              `        df = DataFrame(t=sol[:t], actual=sol[model.${signal}])`
            );
            testlines.push(
              `        dfr = CSV.read("snapshots/${id}.ref", DataFrame)`
            );
            testlines.push(
              `        plot(sol, idxs=[model.${signal}], width=2, label="Actual value of ${signal}")`
            );
            testlines.push(
              `        scatter!(dfr.t, dfr.expected, mc=:red, ms=3, label="Expected value of ${signal}")`
            );
            const initial = caseDef.expect.initial[signal];
            if (initial !== undefined) {
              testlines.push(
                `        plot!([df.t[1]], [${initial}], seriestype=:scatter, label="Initial Condition for ${signal}")`
              );
            }
            const final = caseDef.expect.final[signal];
            if (final !== undefined) {
              testlines.push(
                `        plot!([df.t[end]], [${final}], seriestype=:scatter, label="Final Condition for ${signal}")`
              );
            }
            testlines.push(`        mkpath("comparisons")`);
            testlines.push(`        savefig("comparisons/${id}.png")`);
            testlines.push(`      end`);
            testlines.push(`    else`);
            testlines.push(`      mkpath("snapshots")`);
            testlines.push(
              `      CSV.write("snapshots/${id}.ref", DataFrame(t=ref_times, expected=[sol(t, idxs=model.${signal}) for t in ref_times]))`
            );

            testlines.push(`    end`);
          }
          testlines.push(`end`);
        }
      } else {
        modelLog("No instance metadata found for %s", instance.name);
      }
    }

    if (diagram !== "") {
      deflines.push("");
      deflines.push(`Base.show(io::IO, a::MIME"image/svg+xml", t::typeof(${def.name.value})) = print(io,
  """<div style="height: 100%; width: 100%; background-color: white"><div style="margin: auto; height: 500px; width: 500px; padding: 200px">${diagram}</div></div>""")`);
    }
  } catch (e) {
    ret.push(...toProblems(e));
  }

  for (const p of ret) {
    deflines.push(
      `# Code generation issue: [${p.severity}] ${p.title}: ${p.details}`
    );
  }

  if (precomplines.length > 0) {
    await handler.precompilation(module, precomplines.join("\n"));
  }

  await handler.source(
    experimentKey(module, def.name.value),
    explines.join("\n")
  );

  await handler.source(testKey(module, def.name.value), testlines.join("\n"));

  await handler.source(
    definitionKey(module, def.name.value),
    deflines.join("\n")
  );

  return ret;
}

function requiresConnect(
  con: ConnectionInstance,
  analysis_points: AnalysisPointInstance[]
) {
  const conRefs = new Set([...con.connectors.map(unparseExpression)]);
  for (const ap of analysis_points) {
    const start = unparseExpression(ap.connectors[0]);
    const end = unparseExpression(ap.connectors[1]);
    if (conRefs.has(start) && conRefs.has(end)) {
      return true;
    }
  }
  return false;
}

function parameterDeclaration(
  cn: string,
  c: VariableInstance,
  file: FileLevelNode,
  options: MTKCodeGenerationOptions,
  arrayName: string,
  f: (expr: Expression) => Expression
): Maybe<string> {
  /** Create an array to store MTK metadata */
  const mtkMetadata: string[] = [];

  /** If this instance has a doc string, add it as `description` metadata */
  if (c.doc_string !== null) {
    mtkMetadata.push(`description = "${c.doc_string.value}"`);
  }

  /** If this is a scalar... */
  if (c.type.resolves === "scalar") {
    const units = c.attributes["units"];
    /** ...and it has units AND we should include units... */
    if (units && hasExpression(units) && options.includeUnits) {
      /** ...then add this to the MTK metadata as `unit` */
      getStringEither(units.expr).ifRight((ustr) => {
        mtkMetadata.push(`unit = u"${ustr}"`);
      });
    }
  }

  /**
   * By default, assume there is a local variable with the same name and we use
   * its value to initialize this parameter.
   **/
  let assign = ` = ${cn}`;
  if (c.final || c.qualifier === "constant") {
    const transformedDefault = c.default.map((x) => transformExpression(x, f));
    const v = castOrThrow(
      transformedDefault,
      finalNoInit(
        cn,
        `Expected an initialization expression for a final parameter, but found none`,
        problemSpan(file, c.declarationSpan)
      )
    );
    assign = ` = ${unparseMTKExpression(v)}`;
  }
  if (c.type.resolves === "fun") {
    if (c.type.returns.length !== 1) {
      throw new CompilerAssertionError(
        cn,
        `Functions that return multiple arguments are not currently supported as callable parameters`
      );
    }
    if (c.dims.length !== 0) {
      throw new CompilerAssertionError(
        cn,
        `Arrays of callable parameters are not currently supported`
      );
    }
    return Just(
      `  append!(${arrayName}, @parameters (${cn}::typeof(${cn}ˍ₋value))(..) = ${cn}ˍ₋value)`
    );
  } else {
    const ctype = determineMTKType(c.type);
    const dims =
      c.dims.length > 0
        ? `[1:${c.dims.map(unparseMTKExpression).join(", ")}]`
        : "";
    if (mtkMetadata.length > 0) {
      return Just(
        `  append!(${arrayName}, @parameters (${cn}${dims}::${ctype}${assign}), [${mtkMetadata.join(", ")}])`
      );
    } else {
      return Just(
        `  append!(${arrayName}, @parameters (${cn}${dims}::${ctype}${assign}))`
      );
    }
  }
}

function variableDeclaration(
  cn: string,
  c: VariableInstance,
  options: MTKCodeGenerationOptions
): Maybe<string> {
  const metadata: string[] = [];
  if (c.doc_string !== null) {
    metadata.push(`description = "${c.doc_string.value}"`);
  }
  if (c.type.resolves === "scalar") {
    const units = c.attributes["units"];
    if (units && hasExpression(units) && options.includeUnits) {
      getStringEither(units.expr).ifRight((ustr) => {
        metadata.push(`unit = u"${ustr}"`);
      });
    }
    const guess = extractGuess(c.attributes);
    guess.ifJust((v) => {
      metadata.push(`guess = ${v}`);
    });
    const priority = c.attributes["statePriority"];
    if (priority !== undefined && hasExpression(priority)) {
      const val = unparseExpression(priority.expr);
      if (val !== "0") {
        metadata.push(`state_priority = ${val}`);
      }
    }
  }
  const dims =
    c.dims.length > 0
      ? `[1:${c.dims.map(unparseMTKExpression).join(", ")}]`
      : "";

  // FIX: include some kind of default attribute and use that
  if (metadata.length > 0) {
    return Just(
      `  append!(${variablesVariable}, @variables (${cn}(t))${dims}, [${metadata.join(", ")}])`
    );
  } else {
    return Just(
      `  append!(${variablesVariable}, @variables (${cn}(t))${dims})`
    );
  }
}

function formulatePathParameterArguments(
  pathVariables: Record<string, VariableInstance>
): string[] {
  const ret: string[] = [];
  for (const [varname, v] of Object.entries(pathVariables)) {
    if (!v.final) {
      const rhs = v.default.mapOrDefault(unparseMTKExpression, "nothing");
      ret.push(`${varname}=${rhs}`);
    }
  }
  return ret;
}

function formulateStructuralParameterArguments(
  parameters: Array<[string, VariableInstance]>
): string[] {
  const ret: string[] = [];
  for (const [varname, v] of parameters) {
    if (v.final) {
      continue;
    }
    if (
      v.type.resolves === "scalar" ||
      v.type.resolves === "struct" ||
      v.type.resolves === "enum"
    ) {
      ret.push(
        `${varname}=${v.default.mapOrDefault(unparseMTKExpression, "nothing")}`
      );
    }
  }
  return ret;
}

function formulateParametricParameterArguments(
  parameters: Array<[string, VariableInstance]>
): string[] {
  const ret: string[] = [];
  for (const [varname, v] of parameters) {
    if (v.final) {
      continue;
    }
    switch (v.type.resolves) {
      case "scalar":
      case "struct":
      case "enum":
        ret.push(
          `${varname}=${v.default.mapOrDefault(unparseMTKExpression, "nothing")}`
        );
      default:
        break;
    }
  }
  return ret;
}

export interface CommonConnectorVariable {
  connectorName: string;
  elementName: string;
  type: QualifiedType;
}

function pathVariableTransform(connectors: Array<CommonConnectorVariable>) {
  return (expr: Expression): Expression => {
    modelLog(
      "Checking if %s starts with any of these: %j",
      unparseExpression(expr),
      connectors.map((x) => `${x.connectorName}.${x.elementName})`)
    );
    switch (expr.type) {
      case "cref": {
        const replacement = transformRef(expr, connectors);
        if (replacement.isJust()) {
          modelLog("  Yep");
          return replacement.unsafeCoerce();
        }
        break;
      }
    }
    modelLog("  Nope");
    return expr;
  };
}

type EquationTransformer = (eq: EquationInstance) => EquationInstance;

function transformEquations(
  f: (expr: Expression) => Expression
): EquationTransformer {
  return (eq: EquationInstance): EquationInstance => {
    const lhs = transformExpression(eq.lhs, f);
    const rhs = transformExpression(eq.rhs, f);
    return {
      ...eq,
      lhs,
      rhs,
      index: eq.index,
      origin: eq.origin,
    };
  };
}

function extractConnectorPathVariables(
  connectors: Array<[string, ConnectorInstance]>
): CommonConnectorVariable[] {
  const ret: CommonConnectorVariable[] = [];
  for (const [varname, v] of connectors) {
    if (v.def.kind === "strcon") {
      for (const [ename, elem] of Object.entries(v.def.elements)) {
        if (elem.qualifier === "path") {
          ret.push({
            connectorName: varname,
            elementName: ename,
            type: elem.type,
          });
        }
      }
    }
  }
  return ret;
}

function formulateCommonArguments(
  continuitySets: ContinuitySetInstance[]
): string[] {
  return continuitySets
    .filter((x) => x.master.isNothing())
    .map((x, i) => `${masterArgumentName(i)}`);
}

function determineMTKType(t: ResolvedType): string {
  switch (t.resolves) {
    case "scalar":
      switch (qualifiedName(t.base)) {
        case "Real":
          return "Float64";
        case "Integer":
          return "Int64";
        case "Boolean":
          return "Bool";
        case "String":
          return "String";
        case "Native":
          return t.derived.mapOrDefault((x) => x.name.value, "Nothing");
        /* istanbul ignore next */
        default:
          throw new CompilerAssertionError(
            "determinMTKType",
            `Expected a builtin type, got ${qualifiedName(t.base)}`
          );
      }
    case "enum": {
      return `Union{${Object.keys(t.def.cases)
        .map((k) => `${t.def.name.value}.${k}`)
        .join(",")}}`;
    }
    case "struct": {
      return t.def.name.value;
    }
    default:
      throw new UnimplementedError(
        "determineMTKType",
        `The function determineMTKType cannot (yet) handle ${t.resolves} types`
      );
  }
}

function masterArgumentName(index: number) {
  return `continuity__graph${index}`;
}

function generateSubcomponents(
  query: QueryHandler,
  instance: ModelInstance,
  connectors: Entries<ConnectorInstance>,
  components: Entries<() => Result<ComponentInstance>>
): string[] {
  const problems: Problem[] = [];
  const syslines: string[] = [];
  // Write components
  if (connectors.length + components.length > 0) {
    // Write out all struct connectors.  Directional connectors are currently
    // written later as variables.
    for (const [cn, c] of connectors) {
      try {
        modelLog("  Processing connector %s in %s", cn, instance.name.value);
        if (c.kind === "strcon") {
          const lib = query(
            getLibraryNode(query(getDefinitionRelations(c.def)).library)
          );

          lib.ifResult((v) => {
            if (c.indices.length === 0) {
              const create =
                v.name === baseLibraryName
                  ? `__${baseLibraryName}__${c.def.name.value}()`
                  : `${FullyQualifiedName(query, c.def)}()`;
              syslines.push(
                `  push!(${systemsVariable}, @named ${cn} = ${create})`
              );
            } else {
              const args = `; name=Symbol("${cn}", ${c.indices.map((ind) => `"_", ${ind.variable}`).join(", ")})`;
              const create =
                v.name === baseLibraryName
                  ? `__${baseLibraryName}__${c.def.name.value}(${args})`
                  : `${FullyQualifiedName(query, c.def)}(${args})`;
              syslines.push(
                `  ${cn} = ODESystem[]`,
                `  for ${c.indices.map((ind) => `${ind.variable} in ${unparseMTKExpression(ind.range)}`).join(", ")}`,
                `    push!(${cn}, ${create})`,
                `  end`,
                `  append!(${systemsVariable}, ${cn})`
              );
            }
          }, problems);
        }
      } catch (e: any) {
        console.error(
          `Exception thrown while generating connector ${cn} in instance ${instance.name.value}: ${e.message}`
        );
        throw e;
      }
    }

    const def = query(instance.def);
    /**
     * Loop over all components so we can add lines to `systems`
     * that instantiate each component.
     */
    for (const [cn, comp] of components) {
      comp().ifResult((c) => {
        try {
          modelLog(
            "  Processing subcomponent %s in %s",
            cn,
            instance.name.value
          );

          /**
           * This are the baseline modifications for each component.
           */
          const init_mods: Record<string, Expression> = {};
          for (const [k, v] of Object.entries(c.mods)) {
            if (hasExpression(v)) {
              init_mods[k] = v.expr;
            }
          }
          modelLog("Initial mods for component %s: %j", cn, init_mods);

          // Loop over all connectors in the nested component
          // Check if they have any common variables
          // If so, loop over common sets
          /**
           * Loop over all common sets and see if any of the connectors
           * inside this component require initializations.
           */
          for (let setn = 0; setn < c.instance.continuityGraph.length; setn++) {
            const set = c.instance.continuityGraph[setn];
            modelLog(
              "  Considering set %d of %s: %j",
              setn,
              cn,
              stringifyContinuitySets([set])
            );
            // The set of local connectors that are in this common set
            const cons = new Set<string>();
            set.local.map((x) => cons.add(unparseExpression(x)));
            modelLog(
              "    Local variables in %s that reference this set: %j",
              cn,
              [...cons]
            );
            if (set.master.isJust() && set.local.length > 0) {
              throw new CompilerAssertionError(
                cn,
                `Component ${cn} in ${def.name.value} has external connectors with common variables that linked to a local common variable declaration, this is not allowed`
              );
            }
            for (const [conname, con] of Object.entries(
              c.connectorDefinition
            )) {
              modelLog("      Looking at definition for connector %s", conname);

              if (con.kind === "strcon") {
                for (const ename of Object.keys(con.elements)) {
                  const fqn = `${conname}.${ename}`;
                  modelLog("        Looking at element %s (%s)", ename, fqn);
                  if (cons.has(fqn)) {
                    // FIX: Only if this connector is in a continuity graph
                    init_mods[masterArgumentName(setn)] = compRef([
                      deref(
                        localPathMaster(instance, def, `${cn}.${fqn}`),
                        [],
                        null
                      ),
                    ]);
                    modelLog(
                      "          Connector %s is part of local variables in set %d",
                      fqn,
                      setn,
                      [...cons]
                    );
                  } else {
                    modelLog(
                      "          Connector %s is NOT part of local variables in set %d (%j)",
                      fqn,
                      setn,
                      [...cons]
                    );
                  }
                }
              }
            }
          }

          modelLog(
            "Determine initialization expression for subcomonent %s",
            instance.name.value
          );
          const cdef = query(c.instance.def);
          const cfqn = FullyQualifiedName(query, cdef);
          modelLog("  Fully qualified name is %s", cfqn);
          if (c.indices.length === 0) {
            const init_expr = functionCall(
              compRef([
                {
                  name: cfqn,
                  indices: [],
                  span: null,
                },
              ]),
              [],
              init_mods,
              null
            );
            const create = unparseMTKExpression(init_expr);
            syslines.push(
              `  push!(${systemsVariable}, @named ${cn} = ${create})`
            );
          } else {
            const init_expr = functionCall(
              compRef([
                {
                  name: cfqn,
                  indices: [],
                  span: null,
                },
              ]),
              [],
              {
                ...init_mods,
                name: functionCall(
                  compRef([{ name: "Symbol", indices: [], span: null }]),
                  [
                    stringLiteral(cn, false, null),
                    ...c.indices.flatMap((ind) => [
                      stringLiteral("_", false, null),
                      compRef([
                        { name: ind.variable, indices: [], span: null },
                      ]),
                    ]),
                  ],
                  {},
                  null
                ),
              },
              null
            );
            const create = unparseMTKExpression(init_expr);
            syslines.push(
              `  ${cn} = ODESystem[]`,
              `  for ${c.indices.map((ind) => `${ind.variable} in ${unparseMTKExpression(ind.range)}`).join(", ")}`,
              `    push!(${cn}, ${create})`,
              `  end`,
              `  append!(${systemsVariable}, ${cn})`
            );
          }
        } catch (e: any) {
          console.error(
            `Exception thrown while generating connector ${cn} in instance ${instance.name.value}: ${e.message}`
          );
          throw e;
        }
      }, problems);
    }
    for (const prob of problems) {
      console.error(
        `Error generating MTK subcomponents: `,
        stringifyProblem(prob)
      );
    }
  }
  return syslines;
}

function localPathMaster(
  instance: ModelInstance,
  def: ComponentDefinition,
  fqn: string
): string {
  for (let i = 0; i < instance.continuityGraph.length; i++) {
    const set = instance.continuityGraph[i];
    if (set.nested.some((x) => unparseExpression(x) === fqn)) {
      return set.master.mapOrDefault(unparseExpression, masterArgumentName(i));
    }
  }
  throw new CompilerAssertionError(
    "localPathMaster",
    `Expected to find ${fqn} in at least one continuity graph for ${def.name.value}`
  );
}

function transformRef(expr: CompRef, connectors: CommonConnectorVariable[]) {
  for (const ccv of connectors) {
    if (
      expr.elems.length >= 2 &&
      expr.elems[0].indices.length === 0 &&
      expr.elems[0].name === ccv.connectorName &&
      expr.elems[1].indices.length === 0 &&
      expr.elems[1].name === ccv.elementName
    ) {
      const ret = compRef([
        {
          name: `${ccv.connectorName}__${ccv.elementName}`,
          indices: [],
          span: null,
        },
        ...expr.elems.slice(2),
      ]);
      return Just(ret);
    }
  }
  return Nothing;
}

function isSimpleEquation(x: EquationInstance) {
  return (
    x.lhs.type === "cref" &&
    (x.rhs.type === "ilit" ||
      x.rhs.type === "rlit" ||
      x.rhs.type === "cref" ||
      x.rhs.type === "blit" ||
      x.rhs.type === "slit" ||
      x.rhs.type === "ulit")
  );
}

function emitRelation(
  rel: RelationInstance,
  instance: ModelInstance,
  query: QueryHandler,
  prefix: string
) {
  const lines = new Lines(prefix);
  switch (rel.kind) {
    case "eq":
      if (rel.initial) {
        if (isSimpleEquation(rel)) {
          lines.add(
            `${defaultsVariable}[${unparseMTKExpression(rel.lhs)}] = (${unparseMTKExpression(
              rel.rhs
            )})`
          );
        } else {
          lines.add(
            `push!(${initialEquationsVariable}, ${unparseMTKEquation(rel)})`
          );
        }
      } else {
        lines.add(`push!(${equationsVariable}, ${unparseMTKEquation(rel)})`);
      }
      break;
    case "ap":
      lines.add(
        `push!(${equationsVariable}, AnalysisPoint() ~ AnalysisPoint(${unparseMTKExpression(
          rel.connectors[0]
        )}, :${rel.name.value}, [${unparseMTKExpression(rel.connectors[1])}]))`
      );
      break;
    case "strcon": {
      const expr = functionCall(
        compRef([{ name: "connect", indices: [], span: null }]),
        rel.connectors,
        {},
        null
      );
      lines.add(`push!(${equationsVariable}, ${unparseMTKExpression(expr)})`);
      break;
    }
    case "sclcon":
      lines.add(emitScalarConnection(rel, instance));
      break;
    case "forl":
      const indices = rel.indices.map(
        (ind) => `${ind.variable} in ${unparseMTKExpression(ind.range)}`
      );
      lines.add(`for ${indices.join(", ")}`);
      for (const child of rel.instances) {
        lines.add(emitRelation(child, instance, query, prefix + "  "));
      }
      lines.add("end");
      break;
    case "ifs":
      lines.add(`if ${unparseMTKExpression(rel.cond)}`);
      for (const yr of rel.yesInstances) {
        lines.add(emitRelation(yr, instance, query, prefix + "  "));
      }
      for (const ec of rel.elseInstances) {
        lines.add(`elseif ${unparseMTKExpression(ec.cond)}`);
        for (const er of ec.instances) {
          lines.add(emitRelation(er, instance, query, prefix + "  "));
        }
      }
      lines.add(`else`);
      for (const nr of rel.noInstances) {
        lines.add(emitRelation(nr, instance, query, prefix + "  "));
      }
      lines.add(`end`);
      break;
    case "sw":
      /**
       * Tag each case clause with its index.  We will need this later to
       * find the instantiated relations associated with that case (becuase
       * those relations are stored associatd with the case index)
       */
      const indexedCases = rel.cases.map((x, i) => [x, i] as const);

      /**
       * Now divide this into "real" cases vs. the default case
       */
      const cases = indexedCases.filter((x) => x[0].caseid.value !== "default");
      const def = indexedCases.find((x) => x[0].caseid.value === "default");

      /** If there is not default and not "real" cases, do nothing */
      if (def === undefined && cases.length === 0) {
        // Empty switch statement
        break;
      }
      /** If there are no "real" cases but there is a default, just emit its relations */
      if (cases.length === 0 && def !== undefined) {
        // Switch statement with only a default so just add those relations
        for (const r of rel.instances[def[1]]) {
          lines.add(emitRelation(r, instance, query, prefix));
        }
        break;
      }

      // TODO: if this enum exists in another package, the name needs to be fully
      // qualified.
      if (!sameModule(rel.enum.def, query(instance.def), query)) {
        throw new CompilerAssertionError(
          "emitRelation",
          "Handling of enums defined in other modules is not yet supported"
        );
      }
      const enumName = rel.enum.def.name.value;
      const first = cases[0];
      const mid = def === undefined ? cases.slice(1, -1) : cases.slice(1);
      const last = def === undefined ? cases[cases.length - 1] : def;
      lines.add(
        `if typeof(${unparseMTKExpression(rel.val)})===${buildEnumStructName(enumName, first[0].caseid.value)}`
      );
      for (const nr of rel.instances[first[1]]) {
        lines.add(emitRelation(nr, instance, query, prefix + "  "));
      }
      for (const m of mid) {
        lines.add(
          `elseif typeof(${unparseMTKExpression(rel.val)})===${buildEnumStructName(enumName, m[0].caseid.value)}`
        );
        for (const nr of rel.instances[m[1]]) {
          lines.add(emitRelation(nr, instance, query, prefix + "  "));
        }
      }
      lines.add(`else`);
      for (const nr of rel.instances[last[1]]) {
        lines.add(emitRelation(nr, instance, query, prefix + "  "));
      }
      lines.add(`end`);
      break;
    case "assert":
    case "cont":
      throw new CompilerAssertionError(
        "emitRelation",
        `emitRelation called for ${rel.kind} relation...this should not happen`
      );
      break;
    default:
      assertUnreachable(rel);
  }
  return lines.toString();
}

function sameModule(def1: Definition, def2: Definition, query: QueryHandler) {
  const rels1 = query(getDefinitionRelations(def1));
  const rels2 = query(getDefinitionRelations(def2));
  return rels1.module === rels2.module;
}

function enumConstructorTransform(
  query: QueryHandler,
  instance: ModelInstance
) {
  return (e: Expression): Expression => {
    if (e.type === "call") {
      const t = query(
        resolveType(
          [createToken(e.func.elems[0].name, e.func.elems[0].span)],
          query(instance.def),
          []
        )
      );
      if (
        t.hasValue() &&
        t.value.resolves === "enum" &&
        e.func.elems.length === 2
      ) {
        const alt = functionCall(
          compRef([
            deref(
              buildEnumStructName(e.func.elems[0].name, e.func.elems[1].name),
              [],
              null
            ),
          ]),
          e.positional,
          e.keyword,
          null
        );
        return alt;
      }
    }
    return e;
  };
}

function emitScalarConnection(
  con: ConnectionInstance,
  instance: ModelInstance
) {
  const lines = new Lines("");

  /**
   * Currently MTK requires that scalar connections list the output
   * variable first.  So if `scalar_connect` is enabled, we need to
   * sort them with output first.
   */
  if (
    requiresConnect(con, instance.relations.filter(isAnalysisPointInstance))
  ) {
    const pairs = con.connectors.map((x, i) => ({
      connector: x,
      qualifier: con.qualifiers[i],
      index: i,
    }));
    pairs.sort(
      (a, b) =>
        (a.qualifier === "output" ? 0 : 1) - (b.qualifier === "output" ? 0 : 1)
    );
    const connectors = pairs.map((x) => x.connector);
    lines.add(
      `push!(${equationsVariable}, connect(${connectors
        .map((c) => unparseMTKExpression(c))
        .join(", ")}))`
    );
  } else {
    for (let i = 0; i < con.connectors.length - 1; i++) {
      // Don't do this pairwise if scalar connections are allowed!
      const lhs = con.connectors[i];
      const rhs = con.connectors[i + 1];
      /**
       * if every "connector" in the connect statement is actually listed as
       * a variable in this instance, then we really need an equation. This
       * connect is either a mistake (which we should probably treat as an
       * error) or it is because the variables are from directional
       * connectors which, at the MTK level, are treated as variables
       * because MTK doesn't really handle connect(...) of variables with
       * `input` or `output` metadata.  In short, this is a bit of a hack.
       */
      lines.add(
        `push!(${equationsVariable}, ${unparseMTKExpression(lhs)} ~ ${unparseMTKExpression(
          rhs
        )})`
      );
    }
  }
  return lines.toString();
}
