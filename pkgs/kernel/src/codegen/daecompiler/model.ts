import {
  baseLibraryName,
  Problem,
  problemError,
  Result,
  toProblems,
} from "@juliacomputing/dyad-common";
import {
  ContinuitySetInstance,
  ConnectorInstance,
  EquationInstance,
  ModelInstance,
  ScalarConnectorInstance,
  stringifyContinuitySets,
  VariableInstance,
  isEquationInstance,
  isConnectionInstance,
} from "../../instantiate/index.js";
import { unparseDAEEquation, unparseDAEExpression } from "../equation.js";
import {
  CompRef,
  ComponentDefinition,
  Expression,
  DyadLibrary,
  ProblemSpan,
  QualifiedType,
  compRef,
  deref,
  functionCall,
  qualifiedName,
  transformExpression,
  hasExpression,
  hasNested,
} from "@juliacomputing/dyad-ast";
import { walkInstance } from "../../instantiate/walk.js";
import { normalizeDefinition } from "../../metadata/index.js";
import { generateDiagram } from "../../index.js";
import {
  QueryHandler,
  ResolvedType,
  problemSpan,
  stringifyProblem,
} from "../../workspace/index.js";

import debug from "debug";
import {
  DAEHandler,
  ModuleName,
  definitionKey,
  experimentKey,
  testKey,
} from "./events.js";
import {
  connectorDocString,
  generateDocStringAsComment,
  parameterDocString,
  variableDocString,
} from "./docs.js";
import { FullyQualifiedName } from "../mtk/fqn.js";
import {
  CompilerAssertionError,
  UnimplementedError,
} from "../../workspace/errors.js";
import { DAECodeGenerationOptions } from "./options.js";
import { Just, Maybe, Nothing } from "purify-ts/Maybe";
import { unparseExpression } from "@juliacomputing/dyad-parser";
import { ComponentInstance } from "../../instantiate/component.js";
import { Instance } from "../../instantiate/instance.js";
import { getLibraryNode } from "../../workspace/selectors/nodes.js";
import { getDefinitionRelations } from "../../workspace/selectors/relations.js";

export type Entries<T> = Array<[string, T]>;

const modelLog = debug("codegen:mtk:model");
const instanceLog = debug("codegen:inst");

const partialProblem = problemError<ProblemSpan>(
  "partial-problem",
  "Instantiation of partial model"
);

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const invalidConnect = problemError<ProblemSpan>(
  "invalid-connect",
  "Invalid connect statement"
);

export async function generateComponentDiagram(
  instance: ModelInstance,
  module: ModuleName,
  query: QueryHandler
) {
  return await generateDiagram("", instance, query);
}

export async function emitComponent(
  instance: ModelInstance,
  library: DyadLibrary,
  module: ModuleName,
  diagram: string,
  handler: DAEHandler,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  options: DAECodeGenerationOptions,
  query: QueryHandler
): Promise<Array<Problem<any>>> {
  modelLog(
    "Emitting component %s in module .%s",
    instance.name.value,
    module.join(".")
  );
  const def = query(instance.def);
  const ret: Problem[] = [];
  const deflines: string[] = [];
  const testlines: string[] = [];
  const explines: string[] = [];
  const precomplines: string[] = [];

  try {
    // QUESTION: Should we publish partial models (allowing DAE models to extend
    // from Dyad models) or should we require extension only via Dyad?
    if (instance.qualifier === "partial") {
      ret.push(
        partialProblem(
          instance.name.value,
          `Attempted to instantiate partial model ${instance.name.value}`,
          problemSpan(def, instance.name.span)
        )
      );
    }

    if (instance.qualifier === "external") {
      deflines.push(
        `# Component ${instance.name.value} is an external component definition.  This means that the`,
        `# code for this component should be written in native Julia and will not be generated by`,
        `# the dyad compiler`
      );
    }

    const connectors = Object.entries(instance.connectors);
    const components = Object.entries(instance.components);
    const variables = Object.entries(instance.variables);
    const parameters = Object.entries(instance.parameters);
    const constants = Object.entries(instance.constants);
    const paths = Object.entries(instance.pathVariables);
    const connectorPathVariables = extractConnectorPathVariables(connectors);
    const pathTransform = pathVariableTransform(connectorPathVariables);
    const parameterTransform = parameterAccessTransform(parameters);

    modelLog(
      "Connector path variables for %s are %j",
      def.name.value,
      connectorPathVariables
    );

    const dcons = connectors.filter(
      (x): x is [string, ScalarConnectorInstance] => x[1].kind === "sclcon"
    );

    instanceLog("Instance of %s: %j", instance.name, instance);

    if (instance.qualifier !== "external") {
      {
        // struct FooParams
        deflines.push(`@kwdef struct ${instance.name.value}Params`);
        for (const [cn, c] of parameters) {
          parameterDeclaration(cn, c, options).ifJust((line) =>
            deflines.push(line)
          );
        }
        deflines.push(`end`);
        deflines.push(``);
      }

      {
        // struct FooContents
        deflines.push(`struct ${instance.name.value}Contents`);
        // (this order must match the order these are passed into the constructor below)
        for (const [name, v] of variables) {
          deflines.push(`  ${name}::${determineDAEType(v.type)}`);
        }
        for (const [name, p] of parameters) {
          deflines.push(`  ${name}::${determineDAEType(p.type)}`);
        }
        for (const [name, c] of components) {
          c().ifResult((c) => {
            const def = query(c.instance.def);
            deflines.push(
              `  ${name}::${FullyQualifiedName(query, def)}Contents`
            );
          }, ret);
        }
        for (const [name, c] of connectors) {
          const rels = query(getDefinitionRelations(c.def));
          const lib = query(getLibraryNode(rels.library));
          lib.ifResult((v) => {
            if (v.name === baseLibraryName) {
              // use temporary connector or DAE function
              deflines.push(
                `  ${name}::__${baseLibraryName}__${c.def.name.value}`
              );
            } else {
              deflines.push(`  ${name}::${FullyQualifiedName(query, c.def)}`);
            }
          }, ret);
        }
        deflines.push(`end`);
        deflines.push(``);
      }

      {
        // function (::FooParams)( )::FooContents
        const doc_string: string[] = [
          `   ${instance.name.value}(; ${[
            "name",
            ...parameters.filter((x) => !x[1].final).map((x) => x[0]),
          ].join(", ")})`,
          instance.doc_string === null ? "" : instance.doc_string.value,
          parameterDocString(parameters.filter((x) => !x[1].final)),
          connectorDocString(connectors),
          variableDocString(variables),
        ].filter((x) => x !== "");

        if (doc_string.length > 0) {
          deflines.push(`@doc Markdown.doc"""
${doc_string.join("\n\n")}
"""`);
        }

        // Construct function arguments.  Name is always present, plus the names
        // of all variables
        const args = [
          //"name",
          ...formulateCommonArguments(instance.continuityGraph),
          //...formulateParametricParameterArguments(parameters), // TODO (DAE)
        ];

        modelLog("Writing header for component %s", instance.name.value);

        deflines.push(
          `function (__self::${instance.name.value}Params)(; ${args.join(
            ", "
          )})`
        );

        modelLog("Analyzing paths in %s", instance.name.value);
        /**
         * We need to define the common stuff first because it is structural and
         * can be referenced in following lines.
         **/
        if (paths.length > 0) {
          // TODO (DAE): path variables connectors
          throw new UnimplementedError(
            "emitComponent",
            `Generated DAECompiler code does not yet support scalar connectors.`
          );
        }

        modelLog("Generating subcomponents for %s", instance.name.value);

        const syslines = generateSubcomponents(
          query,
          instance,
          connectors,
          components
        );
        deflines.push(...syslines);

        if (dcons.length > 0) {
          // TODO (DAE): scalar connectors
          throw new UnimplementedError(
            "emitComponent",
            `Generated DAECompiler code does not yet support scalar connectors.`
          );
        }

        if (variables.length > 0) {
          for (const [cn, c] of variables) {
            variableDeclaration(cn, c, options).ifJust((line) => {
              deflines.push(line);
            });
          }
        }

        /**
       * begin
          @symcheck J > 0 || throw(ArgumentError("Expected `J` to be positive"))
        end
      */

        if (constants.length > 0) {
          // TODO (DAE): constant
          throw new UnimplementedError(
            "emitComponent",
            `Generated DAECompiler code does not yet support constants.`
          );
        }

        const transformer = transformEquations((e) =>
          parameterTransform(pathTransform(e))
        );
        const all_equations = instance.relations
          .filter(isEquationInstance)
          .map(transformer);
        const initial_equations = all_equations.filter((x) => x.initial);
        const equations = all_equations.filter((x) => !x.initial);

        if (initial_equations.length > 0) {
          // TODO (DAE): init_equation!
          throw new UnimplementedError(
            "emitComponent",
            `Generated DAECompiler code does not yet support initial equations.`
          );
        }
        for (const eq of equations) {
          deflines.push(...generateDocStringAsComment(eq.doc_string, "    "));
          deflines.push(`  ${unparseDAEEquation(eq)}`);
        }

        // First, merge our connect(...) statements into disjoint nets
        //
        // This isn't strictly necessary, but it keeps the generated code minimal and easy to read.
        const map: Map<String, number> = new Map<String, number>();
        const merged: Set<CompRef>[] = [];
        for (const connection of instance.relations.filter(
          isConnectionInstance
        )) {
          const repr = connection.connectors.find((c) =>
            map.has(unparseDAEExpression(c))
          );
          const id =
            repr === undefined
              ? merged.length
              : map.get(unparseDAEExpression(repr));
          if (id === merged.length) {
            merged.push(new Set<CompRef>());
          }
          if (id === undefined) {
            throw new Error("unexpected");
          }
          for (const connector of connection.connectors) {
            map.set(unparseDAEExpression(connector), id);
            merged[id].add(connector);
          }
        }

        // Then generate the (local) KVL / KCL equations for the connectors
        for (const connection of merged) {
          const connectors = Array.from(connection);
          for (var i = 1; i < connectors.length; i++) {
            const a = connectors[i - 1];
            const b = connectors[i];
            const ainst = walkInstance(instance, def, a, query);
            const binst = walkInstance(instance, def, b, query);

            const pair = ainst.chain((a) =>
              binst.map((b) => [a, b] as [Instance, Instance])
            );

            if (pair.hasProblems()) {
              throw new Error("unexpected"); // TODO
            }

            pair.ifResult(([avalue, bvalue]) => {
              if (avalue.kind !== "strcon") {
                throw new Error("unexpected"); // TODO
              }
              if (bvalue.kind !== "strcon") {
                throw new Error("unexpected"); // TODO
              }

              for (const elem of avalue.elems) {
                if (elem.qualifier === "potential") {
                  deflines.push(
                    `  equation!(${unparseDAEExpression(a)}.${
                      elem.name
                    } - ${unparseDAEExpression(b)}.${elem.name})`
                  );
                }
              }
            }, []);
          }

          const flow_terms: string[] = [];
          for (const a of connectors) {
            const ainst = walkInstance(instance, def, a, query);

            if (ainst.hasProblems()) {
              throw new Error("unexpected"); // TODO
            }

            ainst.ifResult((avalue) => {
              if (avalue.kind !== "strcon") {
                throw new Error("unexpected"); // TODO
              }

              for (const elem of avalue.elems) {
                if (elem.qualifier === "flow") {
                  if (a.elems.length === 1) {
                    // If this connector is attached to this instance (rather than from
                    // a sub-component), the flow contribution is negative.
                    flow_terms.push(
                      `(-${unparseDAEExpression(a)}.${elem.name})`
                    );
                  } else {
                    flow_terms.push(`${unparseDAEExpression(a)}.${elem.name}`);
                  }
                }
              }
            }, []);
          }
          deflines.push!(`  equation!(${flow_terms.join(" + ")})`);
        }

        deflines.push(
          `  return ${instance.name.value}Contents(${[
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ...variables.map(([k, _]) => k),
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ...parameters.map(([k, _]) => "__self." + k),
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ...components.map(([k, _]) => k),
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ...connectors.map(([k, _]) => k),
          ].join(", ")})`
        );
        deflines.push("end");
      }
      deflines.push(`export ${instance.name.value}Params`);
      // FIX: Write out metadata (separate file/output channel?)

      const sys_fqn = [
        library.name,
        ...module,
        `${baseLibraryName}System`,
      ].join(".");
      if (instance.definition_metadata) {
        modelLog(
          "Got instance metadata for %s of: %j",
          instance.name,
          instance.definition_metadata
        );
        const normalized = normalizeDefinition(instance.definition_metadata);
        modelLog(
          "Normalized Dyad metadata for %s: %j",
          instance.name,
          normalized
        );

        // Write out experiments
        for (const [name, exp] of Object.entries(normalized.Dyad.experiments)) {
          modelLog("Emiting experiment %s", name);
          const params = Object.entries(exp.params)
            .map(([k, v]) => `${k}=${v}`)
            .join(",");
          const ics = Object.entries(exp.initial)
            .map(([k, v]) => `model.${k} => ${v}`)
            .join(", ");
          explines.push(
            ...[
              `"""Run model ${instance.name.value} from ${exp.start} to ${exp.stop}"""`,
              `function ${name}()`,
              `  p = ${sys_fqn}(${instance.name.value}Params(${params}))`,
              `  model = IRODESystem(Tuple{typeof(p)})`,
              `  u0 = [${ics}]`,
              `  prob = ODEProblem(model, u0, (${exp.start}, ${exp.stop}), p)`,
              `  sol = solve(prob)`,
              `end`,
              `export ${name}`,
            ]
          );
          modelLog("  Experiment: %j", explines);

          // Every experiment is also a basic test insomuch as it should
          // run without throwing an exception.
          testlines.push(
            ...[
              `@test try`,
              `    ${name}()`,
              `    true`,
              `catch`,
              `    false`,
              `end`,
            ]
          );

          // Experiments are also good for precompilation code
          precomplines.push(`${name}()`);
        }

        // Write out tests
        for (const [name, test] of Object.entries(normalized.Dyad.tests)) {
          const params = Object.entries(test.params)
            .map(([k, v]) => `${k}=${v}`)
            .join(",");
          const ics = Object.entries(test.initial)
            .map(([k, v]) => `model.${k} => ${v}`)
            .join(", ");

          testlines.push(
            ...[
              `@testset "Running test ${name} for ${instance.name.value}" begin`,
              `  p = ${sys_fqn}(${instance.name.value}Params(${params}))`,
              `  u0 = [${ics}]`,
              `  model = IRODESystem(Tuple{typeof(p)})`,
              `  prob = ODEProblem(model, u0, (${test.start}, ${test.stop}), p)`,
              `  sol = solve(prob, ${test.solver}(autodiff=false))`,
              `  @test SciMLBase.successful_retcode(sol)`,
            ]
          );

          for (const [signal, initial] of Object.entries(test.expect.initial)) {
            const atol = test.atol[signal];
            const suffix = atol ? ` atol=${atol}` : "";
            const deref = signal === "t" ? "sol.t" : `sol[model.${signal}]`;
            testlines.push(`  @test ${deref}[1] ≈ ${initial}${suffix}`);
          }
          for (const [signal, final] of Object.entries(test.expect.final)) {
            const atol = test.atol[signal];
            const suffix = atol ? ` atol=${atol}` : "";
            const deref = signal === "t" ? "sol.t" : `sol[model.${signal}]`;
            testlines.push(`  @test ${deref}[end] ≈ ${final}${suffix}`);
          }

          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          for (const [signal, trajectory] of Object.entries(
            test.expect.signals
          )) {
            // TODO: Figure out how to use this to create tests against reference trajectories
          }

          testlines.push(`end`);
        }
      } else {
        modelLog("No instance metadata found for %s", instance.name);
      }
    }

    if (diagram !== "") {
      deflines.push(``);
      deflines.push(`Base.show(io::IO, a::MIME"image/svg+xml", t::${def.name.value}Params) = print(io,
  """
  <div style="height: 100%; width: 100%; background-color: white">
    <div style="margin: auto; height: 500px; width: 500px; padding: 200px">
      ${diagram}
    </div>
  </div>
  """)`);
    }
  } catch (e) {
    ret.push(...toProblems(e));
  }

  for (const p of ret) {
    deflines.push(
      `# Code generation issue: [${p.severity}] ${p.title}: ${p.details}`
    );
  }

  if (precomplines.length > 0) {
    await handler.precompilation(module, precomplines.join("\n"));
  }

  await handler.source(
    experimentKey(module, def.name.value),
    explines.join("\n")
  );

  await handler.source(testKey(module, def.name.value), testlines.join("\n"));

  await handler.source(
    definitionKey(module, def.name.value),
    deflines.join("\n")
  );

  return ret;
}

function parameterDeclaration(
  cn: string,
  c: VariableInstance,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  options: DAECodeGenerationOptions
): Maybe<string> {
  let assign = ` = ${c.default.mapOrDefault(unparseDAEExpression, "nothing")}`;
  const ctype = determineDAEType(c.type);
  return Just(`  ${cn}::${ctype}${assign}`);
}

function variableDeclaration(
  cn: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  c: VariableInstance,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  options: DAECodeGenerationOptions
): Maybe<string> {
  // TODO (DAE): check that the variable name is legal to substitute
  //             as a Symbol without escaping.
  return Just(`  ${cn} = variable(:${cn})`);
}

export interface CommonConnectorVariable {
  connectorName: string;
  elementName: string;
  type: QualifiedType;
}

function pathVariableTransform(connectors: Array<CommonConnectorVariable>) {
  return (expr: Expression): Expression => {
    modelLog(
      "Checking if %s starts with any of these: %j",
      unparseExpression(expr),
      connectors.map((x) => `${x.connectorName}.${x.elementName})`)
    );
    switch (expr.type) {
      case "cref": {
        const replacement = transformRef(expr, connectors);
        if (replacement.isJust()) {
          modelLog("  Yep");
          return replacement.unsafeCoerce();
        }
        break;
      }
    }
    modelLog("  Nope");
    return expr;
  };
}

function parameterAccessTransform(parameters: [string, VariableInstance][]) {
  return (expr: Expression): Expression => {
    switch (expr.type) {
      case "cref": {
        const replacement = transformParameterRef(expr, parameters);
        if (replacement.isJust()) {
          modelLog("  Yep");
          return replacement.unsafeCoerce();
        }
        break;
      }
    }
    modelLog("  Nope");
    return expr;
  };
}

function transformEquations(f: (expr: Expression) => Expression) {
  return (eq: EquationInstance): EquationInstance => {
    const lhs = transformExpression(eq.lhs, f);
    const rhs = transformExpression(eq.rhs, f);
    return {
      ...eq,
      lhs,
      rhs,
      origin: eq.origin,
      index: eq.index,
    };
  };
}

function extractConnectorPathVariables(
  connectors: Array<[string, ConnectorInstance]>
): CommonConnectorVariable[] {
  const ret: CommonConnectorVariable[] = [];
  for (const [varname, v] of connectors) {
    if (v.def.kind === "strcon") {
      for (const [ename, elem] of Object.entries(v.def.elements)) {
        if (elem.qualifier === "path") {
          ret.push({
            connectorName: varname,
            elementName: ename,
            type: elem.type,
          });
        }
      }
    }
  }
  return ret;
}

function formulateCommonArguments(
  continuitySets: ContinuitySetInstance[]
): string[] {
  return continuitySets
    .filter((x) => x.master.isNothing())
    .map((x, i) => `${masterArgumentName(i)}::${determineDAEType(x.type)}`);
}

function determineDAEType(t: ResolvedType): string {
  switch (t.resolves) {
    case "scalar":
      switch (qualifiedName(t.base)) {
        case "Real":
          return "Float64";
        case "Integer":
          return "Int64";
        case "Boolean":
          return "Bool";
        case "String":
          return "String";
        /* istanbul ignore next */
        default:
          throw new CompilerAssertionError(
            "determineDAEType",
            `Expected a builtin type, got ${qualifiedName(t.base)}`
          );
      }
    case "struct": {
      return t.def.name.value;
    }
    case "enum": {
      return `Union{${Object.keys(t.def.cases)
        .map((k) => `${t.def.name.value}.${k}`)
        .join(",")}}`;
    }
    default:
      throw new UnimplementedError(
        "determineDAEType",
        `The function determineDAEType cannot (yet) handle ${t.resolves} types`
      );
  }
}

function masterArgumentName(index: number) {
  return `continuity__graph${index}`;
}

function generateSubcomponents(
  query: QueryHandler,
  instance: ModelInstance,
  connectors: Entries<ConnectorInstance>,
  components: Entries<() => Result<ComponentInstance>>
): string[] {
  const syslines: string[] = [];
  const problems: Problem[] = [];

  // Write components
  if (connectors.length + components.length > 0) {
    // Write out all struct connectors.  Directional connectors are currently
    // written later as variables.
    for (const [cn, c] of connectors) {
      try {
        modelLog("  Processing connector %s in %s", cn, instance.name.value);
        if (c.kind === "strcon") {
          const lib = query(
            getLibraryNode(query(getDefinitionRelations(c.def)).library)
          );

          lib.ifResult((v) => {
            if (v.name === baseLibraryName) {
              // use temporary connector or DAE function
              syslines.push(
                `  ${cn} = __${baseLibraryName}__${c.def.name.value}()`
              );
            } else {
              syslines.push(`  ${cn} = ${FullyQualifiedName(query, c.def)}()`);
            }
          }, problems);
        }
      } catch (e: any) {
        console.error(
          `Exception thrown while generating connector ${cn} in instance ${instance.name.value}: ${e.message}`
        );
        throw e;
      }
    }

    const def = query(instance.def);
    /**
     * Loop over all components so we can add lines to `systems`
     * that instantiate each component.
     */
    for (const [cn, c] of components) {
      const comp = c();
      comp.ifResult((c) => {
        const cdef = query(c.instance.def);
        try {
          modelLog(
            "  Processing subcomponent %s in %s",
            cn,
            instance.name.value
          );

          /**
           * This are the baseline modifications for each component.
           */
          const init_mods: Record<string, Expression> = {};
          for (const [k, v] of Object.entries(c.mods)) {
            if (hasNested(v)) {
              throw new CompilerAssertionError(
                cn,
                "Nested modifications are not currently supported"
              );
            }
            if (hasExpression(v)) {
              init_mods[k] = v.expr;
            }
          }
          modelLog("Initial mods for component %s: %j", cn, init_mods);

          // Loop over all connectors in the nested component
          // Check if they have any common variables
          // If so, loop over common sets
          /**
           * Loop over all common sets and see if any of the connectors
           * inside this component require initializations.
           */
          for (let setn = 0; setn < c.instance.continuityGraph.length; setn++) {
            const set = c.instance.continuityGraph[setn];
            modelLog(
              "  Considering set %d of %s: %j",
              setn,
              cn,
              stringifyContinuitySets([set])
            );
            // The set of local connectors that are in this common set
            const cons = new Set<string>();
            set.local.map((x) => cons.add(unparseExpression(x)));
            modelLog(
              "    Local variables in %s that reference this set: %j",
              cn,
              [...cons]
            );
            if (set.master.isJust() && set.local.length > 0) {
              throw new CompilerAssertionError(
                cn,
                `Component ${cn} in ${def.name.value} has external connectors with common variables that linked to a local common variable declaration, this is not allowed`
              );
            }
            for (const [conname, con] of Object.entries(
              c.connectorDefinition
            )) {
              modelLog("      Looking at definition for connector %s", conname);

              if (con.kind === "strcon") {
                for (const ename of Object.keys(con.elements)) {
                  const fqn = `${conname}.${ename}`;
                  modelLog("        Looking at element %s (%s)", ename, fqn);
                  if (cons.has(fqn)) {
                    // FIX: Only if this connector is in a continuity graph
                    init_mods[masterArgumentName(setn)] = compRef([
                      deref(
                        localPathMaster(instance, def, `${cn}.${fqn}`),
                        [],
                        null
                      ),
                    ]);
                    modelLog(
                      "          Connector %s is part of local variables in set %d",
                      fqn,
                      setn,
                      [...cons]
                    );
                  } else {
                    modelLog(
                      "          Connector %s is NOT part of local variables in set %d (%j)",
                      fqn,
                      setn,
                      [...cons]
                    );
                  }
                }
              }
            }
          }

          modelLog(
            "Determine initialization expression for subcomonent %s",
            instance.name.value
          );
          const cfqn = FullyQualifiedName(query, cdef);
          modelLog("  Fully qualified name is %s", cfqn);
          const init_expr = functionCall(
            compRef([
              {
                name: cfqn,
                indices: [],
                span: null,
              },
            ]),
            [],
            init_mods,
            null
          );
          syslines.push(`  ${cn} = ${unparseDAEExpression(init_expr)}`);
        } catch (e: any) {
          console.error(
            `Exception thrown while generating connector ${cn} in instance ${instance.name.value}: ${e.message}`
          );
          throw e;
        }
      }, problems);
    }
    for (const prob of problems) {
      console.error(`Error generating subcomponents: `, stringifyProblem(prob));
    }
  }
  return syslines;
}

function localPathMaster(
  instance: ModelInstance,
  def: ComponentDefinition,
  fqn: string
): string {
  for (let i = 0; i < instance.continuityGraph.length; i++) {
    const set = instance.continuityGraph[i];
    if (set.nested.some((x) => unparseExpression(x) === fqn)) {
      return set.master.mapOrDefault(unparseExpression, masterArgumentName(i));
    }
  }
  throw new CompilerAssertionError(
    "localPathMaster",
    `Expected to find ${fqn} in at least one continuity graph for ${def.name.value}`
  );
}

function transformParameterRef(
  expr: CompRef,
  parameters: [string, VariableInstance][]
) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  for (const [varname, _] of parameters) {
    if (
      expr.elems.length >= 1 &&
      expr.elems[0].indices.length === 0 &&
      expr.elems[0].name === varname
    ) {
      const ret = compRef([
        {
          name: `__self`,
          indices: [],
          span: null,
        },
        ...expr.elems.slice(0),
      ]);
      return Just(ret);
    }
  }
  return Nothing;
}

function transformRef(expr: CompRef, connectors: CommonConnectorVariable[]) {
  for (const ccv of connectors) {
    if (
      expr.elems.length >= 2 &&
      expr.elems[0].indices.length === 0 &&
      expr.elems[0].name === ccv.connectorName &&
      expr.elems[1].indices.length === 0 &&
      expr.elems[1].name === ccv.elementName
    ) {
      const ret = compRef([
        {
          name: `${ccv.connectorName}__${ccv.elementName}`,
          indices: [],
          span: null,
        },
        ...expr.elems.slice(2),
      ]);
      return Just(ret);
    }
  }
  return Nothing;
}
