import { assertUnreachable } from "@juliacomputing/dyad-common";
import {
  getDefinitionEntity,
  QueryHandler,
  ResolvedType,
  unparseDefinitionEntity,
} from "../../workspace/index.js";
import { codeFence } from "./primitives.js";
import { Definition } from "@juliacomputing/dyad-ast";
import { Just, Maybe, Nothing } from "purify-ts/Maybe";

export interface RenderOptions {
  /**
   * Generate href to another entity.  If no options is provided here, the URN
   * is used (which is unlikely to be useful, so this will almost always be
   * overridden).
   *
   * @param entity
   * @returns URL to the specified entity
   */
  generateHref?: (query: QueryHandler, type: ResolvedType) => Maybe<string>;
  /**
   * Generate HTML within Markdown.  If this isn't specified, then the HTML is
   * just written inline (which should normally be the case for Markdown).  In
   * the case of Documenter.jl, this isn't allowed and a special code fence
   * needs to be used.
   *
   * @param html
   * @returns
   */
  html?: (html: string) => string;
}

/**
 * A version of `RenderOptions` where all optional fields have been
 * filled in either be defaults or overrides.
 */
export type NormalizedRenderOptions = Required<RenderOptions>;

/**
 * Normalize an instance of `RenderOptions`
 *
 * @param opts Raw `RenderOptions`
 * @returns `NormalizedRenderOptions`
 */
export function normalizeRenderOptions(
  opts: RenderOptions
): NormalizedRenderOptions {
  const defaultHref = (): Maybe<string> => Nothing;
  const defaultHtml = (html: string): string => html;
  return {
    generateHref: opts.generateHref ?? defaultHref,
    html: opts.html ?? defaultHtml,
  };
}

/**
 * These are the options that should be used in the cae of documentations
 * generated by Documenter.jl.
 */
export const documenterOptions: NormalizedRenderOptions = {
  generateHref: (e, t) =>
    standardDocumenterHrefs(
      process.env["DYAD_STD_BASE"] ??
        "https://vigilant-adventure-ggzv8m1.pages.github.io/dev/stdlibs",
      process.env["DYAD_DOCS_BASE"] ?? "/",
      e,
      t
    ),
  html: (html: string) => codeFence("@raw html", html),
};

const standardLibraries: string[] = [
  "Dyad",
  "BlockComponentS",
  "ElectricalComponents",
  "TranslationalComponents",
  "RotationalComponents",
  "ThermalComponents",
  "HydraulicComponents",
];

function standardDocumenterHrefs(
  stdBaseURL: string,
  docsBaseURL: string,
  query: QueryHandler,
  rt: ResolvedType
): Maybe<string> {
  const baseOfDef = (def: Definition) => {
    const entity = query(getDefinitionEntity(def));
    const { library, modules } = unparseDefinitionEntity(entity);
    const isStandard = library in standardLibraries;
    const modpath = modules.length === 0 ? "" : modules.join("/");
    const base = isStandard
      ? `${stdBaseURL}/${modpath}`
      : `${docsBaseURL}/${modpath}`;
    return base;
  };
  if (rt.resolves === "scalar") {
    return rt.derived.caseOf({
      Nothing: () => Nothing,
      Just: (d) => Just(`${baseOfDef(d)}/types/${d.name.value}`),
    });
  }
  const base = baseOfDef(rt.def);
  switch (rt.resolves) {
    case "struct":
    case "fun":
    case "enum":
      return Just(`${base}/types/${rt.def.name.value}`);
    case "adef":
      return Just(`${base}/analyses/${rt.def.name.value}`);
    case "cdef": {
      const qual = rt.def.qualifier;
      switch (qual) {
        case "partial":
          return Just(`${base}/types/${rt.def.name.value}`);
        case "test":
          return Just(`${base}/tests/${rt.def.name.value}`);
        case "external":
        case "example":
        case null:
          return Just(`${base}/components/${rt.def.name.value}`);
        default:
          assertUnreachable(qual);
      }
    }
    case "sclcon":
      return Just(`${base}/connectors/${rt.def.name.value}`);

    case "strcon":
      return Just(`${base}/connectors/${rt.def.name.value}`);
    default:
      assertUnreachable(rt);
  }
}
